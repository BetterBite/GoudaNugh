using System.IO;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using OpenAI_API;

/*
Sorry in advance for how terrible this code is.
A lot of it is generated by ChatGPT to get something thrown together.
Ideally we can setup some sort of mic audio stream to use instead of the file handling as well.
*/

public class VoiceInterpreter : MonoBehaviourWithOpenAI
{
    public ChatGPTManager chatGPTManager;
    private System.Diagnostics.Stopwatch stopWatch;
    public override void SetAPI(OpenAIAPI apiFromHandler)
    {
        base.SetAPI(apiFromHandler);
    }

    public async void GetTranscriptionFromFile(string filename) {
        stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Start();

        string resultText = await api.Transcriptions.GetTextAsync(filename);
        Debug.Log(resultText);

        stopWatch.Stop();
        Debug.Log("Time to transcribe input: " + stopWatch.Elapsed.TotalMilliseconds);

        chatGPTManager.GetResponseFromPrompt(resultText);
    }
    public async void GetTranscriptionFromAudioClip(AudioClip clip) {
        byte[] data = ConvertAudioClipToByteArray(clip);

        using (MemoryStream stream = new MemoryStream()) {
            using (BinaryWriter writer = new BinaryWriter(stream)) {
                // Write WAV header
                writer.Write(new char[4] { 'R', 'I', 'F', 'F' });
                writer.Write(data.Length + 36);
                writer.Write(new char[4] { 'W', 'A', 'V', 'E' });
                writer.Write(new char[4] { 'f', 'm', 't', ' ' });
                writer.Write(16); // PCM format
                writer.Write((short)1); // Audio format (1 for PCM)
                writer.Write((short)clip.channels); // Number of channels
                writer.Write(clip.frequency); // Sample rate
                writer.Write(clip.frequency * clip.channels * 4); // Byte rate
                writer.Write((short)(clip.channels * 4)); // Block align
                writer.Write((short)32); // Bits per sample
                writer.Write(new char[4] { 'd', 'a', 't', 'a' });
                writer.Write(data.Length);

                // Write audioData
                writer.Write(data);


                string transcription = await api.Transcriptions.GetTextAsync(stream, "file.wav");

                Debug.Log("Transcription: "+transcription);
            }
        }
    }

    // ChatGPT wrote this
    private static byte[] ConvertAudioClipToByteArray(AudioClip audioClip)
    {
        float[] samples = new float[audioClip.samples * audioClip.channels];
        audioClip.GetData(samples, 0);

        // Convert float samples to byte array
        byte[] byteArray = new byte[samples.Length * 2]; // 2 bytes per sample for Unity AudioClip
        int rescaleFactor = 32767; // To convert float to short

        for (int i = 0; i < samples.Length; i++)
        {
            short intSample = (short)(samples[i] * rescaleFactor);
            byteArray[i * 2] = (byte)(intSample & 0xFF);
            byteArray[i * 2 + 1] = (byte)((intSample >> 8) & 0xFF);
        }

        return byteArray;
    }

    // ChatGPT wrote this
    private static void PutDataInStream(MemoryStream stream, byte[] audioData, AudioClip audioClip)
    {
        BinaryWriter writer = new BinaryWriter(stream);

        // Write WAV header
        writer.Write(new char[4] { 'R', 'I', 'F', 'F' });
        writer.Write(audioData.Length + 36);
        writer.Write(new char[4] { 'W', 'A', 'V', 'E' });
        writer.Write(new char[4] { 'f', 'm', 't', ' ' });
        writer.Write(16); // PCM format
        writer.Write((short)1); // Audio format (1 for PCM)
        writer.Write((short)audioClip.channels); // Number of channels
        writer.Write(audioClip.frequency); // Sample rate
        writer.Write(audioClip.frequency * audioClip.channels * 2); // Byte rate
        writer.Write((short)(audioClip.channels * 2)); // Block align
        writer.Write((short)16); // Bits per sample
        writer.Write(new char[4] { 'd', 'a', 't', 'a' });
        writer.Write(audioData.Length);

        // Write audioData
        writer.Write(audioData);
    }
}
